- Name: Assembly
  Aliases: []
  Description: Execute a dotnet Assembly EntryPoint.
  Author: 
      Name: Ryan Cobb
      Handle: cobbr_io
      Link: https://twitter.com/cobbr_io
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Collections;
    using System.Collections.Generic;
    using Reflect = System.Reflection;

    public static class Task
    {
        public static string Execute(string Assembly, string AssemblyName, string Parameters = "")
        {
            string output = "";
            try
            {
                string[] args = SplitCommandLine(Parameters).ToArray();
                
                TextWriter realStdOut = Console.Out;
                TextWriter realStdErr = Console.Error;
                TextWriter stdOutWriter = new StringWriter();
                TextWriter stdErrWriter = new StringWriter();
                Console.SetOut(stdOutWriter);
                Console.SetError(stdErrWriter);
                
                Assem.AssemblyExecute(Assembly, new Object[] { args });
                
                Console.Out.Flush();
                Console.Error.Flush();
                Console.SetOut(realStdOut);
                Console.SetError(realStdErr);
                
                output = stdOutWriter.ToString();
                output += stdErrWriter.ToString();
            }
            catch (Exception e) { output += e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
            return output;
        }

        // Credit: https://stackoverflow.com/a/298990
        private static IEnumerable<string> SplitCommandLine(string commandLine)
        {
            bool inQuotes = false;

            return commandLine.Split(c =>
            {
                if (c == '\"' || c == '\'')
                    inQuotes = !inQuotes;

                return !inQuotes && c == ' ';
            })
                .Select(arg => arg.Trim().TrimMatchingQuotes('\"').TrimMatchingQuotes('\''))
                .Where(arg => !string.IsNullOrEmpty(arg));
        }

        private static IEnumerable<string> Split(this string str, Func<char, bool> controller)
        {
            int nextPiece = 0;

            for (int c = 0; c < str.Length; c++)
            {
                if (controller(str[c]))
                {
                    yield return str.Substring(nextPiece, c - nextPiece);
                    nextPiece = c + 1;
                }
            }

            yield return str.Substring(nextPiece);
        }

        private static string TrimMatchingQuotes(this string input, char quote)
        {
            if ((input.Length >= 2) && 
                (input[0] == quote) && (input[input.Length - 1] == quote))
                return input.Substring(1, input.Length - 2);

            return input;
        }
    }

    /// <summary>
    /// Assembly is a library for loading .NET assemblies and executing methods contained within them.
    /// </summary>
    public class Assem
    {
        /// <summary>
        /// Loads a specified .NET assembly byte array and executes the EntryPoint.
        /// </summary>
        /// <param name="AssemblyBytes">The .NET assembly byte array.</param>
        /// <param name="Args">The arguments to pass to the assembly's EntryPoint.</param>
        public static void AssemblyExecute(byte[] AssemblyBytes, Object[] Args = null)
        {
            if (Args == null)
            {
                Args = new Object[] { new string[] { } };
            }
            Reflect.Assembly assembly = Load(AssemblyBytes);
            assembly.EntryPoint.Invoke(null, Args);
        }

        /// <summary>
        /// Loads a specified .NET assembly byte array and executes a specified method within a
        /// specified type with specified parameters.
        /// </summary>
        /// <param name="AssemblyBytes">The .NET assembly byte array.</param>
        /// <param name="TypeName">The name of the type that contains the method to execute.</param>
        /// <param name="MethodName">The name of the method to execute.</param>
        /// <param name="Parameters">The parameters to pass to the method.</param>
        /// <returns>GenericObjectResult of the method.</returns>
        public static GenericObjectResult AssemblyExecute(byte[] AssemblyBytes, String TypeName = "", String MethodName = "Execute", Object[] Parameters = default(Object[]))
        {
            Reflect.Assembly assembly = Load(AssemblyBytes);
            Type type = TypeName == "" ? assembly.GetTypes()[0] : assembly.GetType(TypeName);
            Reflect.MethodInfo method = MethodName == "" ? type.GetMethods()[0] : type.GetMethod(MethodName);
            var results = method.Invoke(null, Parameters);
            return new GenericObjectResult(results);
        }

        /// <summary>
        /// Loads a specified base64-encoded .NET assembly and executes a specified method within a
        /// specified type with specified parameters.
        /// </summary>
        /// <param name="EncodedAssembly">The base64-encoded .NET assembly byte array.</param>
        /// <param name="TypeName">The name of the type that contains the method to execute.</param>
        /// <param name="MethodName">The name of the method to execute.</param>
        /// <param name="Parameters">The parameters to pass to the method.</param>
        /// <returns>GenericObjectResult of the method.</returns>
        public static GenericObjectResult AssemblyExecute(String EncodedAssembly, String TypeName = "", String MethodName = "Execute", Object[] Parameters = default(Object[]))
        {
            return AssemblyExecute(Convert.FromBase64String(EncodedAssembly), TypeName, MethodName, Parameters);
        }

        /// <summary>
        /// Loads a specified base64-encoded .NET assembly and executes the EntryPoint.
        /// </summary>
        /// <param name="EncodedAssembly">The base64-encoded .NET assembly byte array.</param>
        /// <param name="Args">The arguments to pass to the assembly's EntryPoint.</param>
        public static void AssemblyExecute(String EncodedAssembly, Object[] Args = default(Object[]))
        {
            AssemblyExecute(Convert.FromBase64String(EncodedAssembly), Args);
        }

        /// <summary>
        /// Loads a specified .NET assembly byte array.
        /// </summary>
        /// <param name="AssemblyBytes">The .NET assembly byte array.</param>
        /// <returns>Loaded assembly.</returns>
        public static Reflect.Assembly Load(byte[] AssemblyBytes)
        {
            return Reflect.Assembly.Load(AssemblyBytes);
        }

        /// <summary>
        /// Loads a specified .NET assembly byte array.
        /// </summary>
        /// <param name="EncodedAssembly">The base64-encoded .NET assembly byte array.</param>
        /// <returns>Loaded assembly.</returns>
        public static Reflect.Assembly Load(string EncodedAssembly)
        {
            return Reflect.Assembly.Load(Convert.FromBase64String(EncodedAssembly));
        }
    }
    /// <summary>
    /// GenericObjectResult for listing objects whose type is unknown at compile time.
    /// </summary>
    public sealed class GenericObjectResult : SharpSploitResult
    {
        public object Result { get; }
        protected internal override IList<SharpSploitResultProperty> ResultProperties
        {
            get
            {
                return new List<SharpSploitResultProperty>
                    {
                        new SharpSploitResultProperty
                        {
                            Name = this.Result.GetType().Name,
                            Value = this.Result
                        }
                    };
            }
        }

        public GenericObjectResult(object Result)
        {
            this.Result = Result;
        }
    }

    /// <summary>
    /// SharpSploitResultList extends the IList interface for SharpSploitResults to easily /// format a list of results from various SharpSploit functions.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class SharpSploitResultList<T> : IList<T> where T : SharpSploitResult
    {
        private List<T> Results { get; } = new List<T>();

        public int Count => Results.Count;
        public bool IsReadOnly => ((IList<T>)Results).IsReadOnly;


        private const int PROPERTY_SPACE = 3;

        /// <summary>
        /// Formats a SharpSploitResultList to a string similar to PowerShell's Format-List function.
        /// </summary>
        /// <returns>string</returns>
        public string FormatList()
        {
            return this.ToString();
        }

        private string FormatTable()
        {
            // TODO
            return "";
        }
        
        /// <summary>
        /// Formats a SharpSploitResultList as a string. Overrides ToString() for convenience.
        /// </summary>
        /// <returns>string</returns>
        public override string ToString()
        {
            if (this.Results.Count > 0)
            {
                StringBuilder builder1 = new StringBuilder();
                StringBuilder builder2 = new StringBuilder();
                for (int i = 0; i < this.Results[0].ResultProperties.Count; i++)
                {
                    builder1.Append(this.Results[0].ResultProperties[i].Name);
                    builder2.Append(new String('-', this.Results[0].ResultProperties[i].Name.Length));
                    if (i != this.Results[0].ResultProperties.Count-1)
                    {
                        builder1.Append(new String(' ', PROPERTY_SPACE));
                        builder2.Append(new String(' ', PROPERTY_SPACE));
                    }
                }
                builder1.AppendLine();
                builder1.AppendLine(builder2.ToString());
                foreach (SharpSploitResult result in this.Results)
                {
                    for (int i = 0; i < result.ResultProperties.Count; i++)
                    {
                        SharpSploitResultProperty property = result.ResultProperties[i];
                        string ValueString = property.Value.ToString();
                        builder1.Append(ValueString);
                        if (i != result.ResultProperties.Count-1)
                        {
                            builder1.Append(new String(' ', Math.Max(1, property.Name.Length + PROPERTY_SPACE - ValueString.Length)));
                        }
                    }
                    builder1.AppendLine();
                }
                return builder1.ToString();
            }
            return "";
        }

        public T this[int index] { get => Results[index]; set => Results[index] = value; }

        public IEnumerator<T> GetEnumerator()
        {
            return Results.Cast<T>().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return Results.Cast<T>().GetEnumerator();
        }

        public int IndexOf(T item)
        {
            return Results.IndexOf(item);
        }

        public void Add(T t)
        {
            Results.Add(t);
        }

        public void AddRange(IEnumerable<T> range)
        {
            Results.AddRange(range);
        }

        public void Insert(int index, T item)
        {
            Results.Insert(index, item);
        }

        public void RemoveAt(int index)
        {
            Results.RemoveAt(index);
        }

        public void Clear()
        {
            Results.Clear();
        }

        public bool Contains(T item)
        {
            return Results.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            Results.CopyTo(array, arrayIndex);
        }

        public bool Remove(T item)
        {
            return Results.Remove(item);
        }
    }

    /// <summary>
    /// Abstract class that represents a result from a SharpSploit function.
    /// </summary>
    public abstract class SharpSploitResult
    {
        protected internal abstract IList<SharpSploitResultProperty> ResultProperties { get; }
    }

    /// <summary>
    /// SharpSploitResultProperty represents a property that is a member of a SharpSploitResult's ResultProperties.
    /// </summary>
    public class SharpSploitResultProperty
    {
        public string Name { get; set; }
        public object Value { get; set; }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: Assembly
    Value: ''
    DefaultValue: ''
    Description: The Assembly to execute.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: false
    FileOption: true
  - Name: AssemblyName
    Value: ''
    DefaultValue: ''
    Description: Name of the assembly.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: Parameters
    Value: ''
    DefaultValue: ''
    Description: The command-line parameters to pass to the assembly's EntryPoint.
    SuggestedValues: []
    Optional: true
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []
- Name: CreateDirectory
  Aliases:
  - mkdir
  Description: Creates all directories and subdirectories in the specified path unless they already exist.
  Author:
      Name: Daniel Duggan
      Handle: _RastaMouse
      Link: https://twitter.com/_RastaMouse
  Help:
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;

    public static class Task
    {
        public static string Execute(string Path)
        {
            try
            {
                var directory = Directory.CreateDirectory(Path);
                return directory.FullName + " created.";
            }
            catch (Exception e) { return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: Path
    Value: ''
    DefaultValue: ''
    Description: The directory to create.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []
- Name: Delete
  Aliases:
  - rm
  - del
  Description: Delete a file or directory.
  Author: 
      Name: Ryan Cobb
      Handle: cobbr_io
      Link: https://twitter.com/cobbr_io
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;

    public static class Task
    {
        public static string Execute(string Path)
        {
            try
            {
                if (File.Exists(Path))
                {
                    File.Delete(Path);
                    return $"File {Path} deleted.";
                }
    			else if (Directory.Exists(Path))
                {
                    Directory.Delete(Path, true);
                    return $"Directory {Path} deleted.";
                }
                else
                {
                    return $"{Path} does not exist.";
                }
            }
            catch (Exception e) { return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: Path
    Value: ''
    DefaultValue: ''
    Description: The path of the file or directory to delete.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []
- Name: Copy
  Aliases:
  - cp
  Description: Copy a file from one location to another.
  Author: 
      Name: Ryan Cobb
      Handle: cobbr_io
      Link: https://twitter.com/cobbr_io
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;

    public static class Task
    {
        public static string Execute(string Source, string Destination)
        {
            try
            {
                File.Copy(Source, Destination);
                return "Successfully copied file from: " + Source + " to: " + Destination;
            }
            catch (Exception e) { return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: Source
    Value: ''
    DefaultValue: ''
    Description: Source file to copy
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: Destination
    Value: .
    DefaultValue: ''
    Description: Destination to copy file to.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []
- Name: Download
  Aliases: []
  Description: Download a file.
  Author: 
      Name: Ryan Cobb
      Handle: cobbr_io
      Link: https://twitter.com/cobbr_io
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;
    using System.Text;
    using System.Linq;
    using System.Collections.Generic;

    public static class Task
    {
        public static Stream OutputStream { get; set; }
        public static string Execute(string FileName)
        {
            try
            {
                using (FileStream fs = File.OpenRead(FileName))
                {
                    byte[] read = new byte[1048576];
                    int count;
                    while ((count = fs.Read(read, 0, read.Length)) > 0)
                    {
                        IEnumerable<byte> finalRead = read.Take(count).AsEnumerable();
                        int b = 0;
                        while (count % 3 != 0 && b != -1)
                        {
                            b = fs.ReadByte();
                            if (b != -1)
                            {
                              finalRead = finalRead.Concat(new byte[] { (byte)b });
                            }
                            count++;
                        }
                        byte[] base64 = Encoding.UTF8.GetBytes(Convert.ToBase64String(finalRead.ToArray()));
                        OutputStream.Write(base64, 0, base64.Length);
                        OutputStream.Flush();
                    }
                }
                OutputStream.Close();
                return "";
            }
            catch (Exception e)
            {
              if (OutputStream != null)
              {
                OutputStream.Close();
              }
              return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace;
            }
        }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: FileName
    Value: ''
    DefaultValue: ''
    Description: Remote file name to download.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []
- Name: Upload
  Aliases: []
  Description: Upload a file.
  Author: 
      Name: Ryan Cobb
      Handle: cobbr_io
      Link: https://twitter.com/cobbr_io
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - NetCore31
  Code: |
    using System;
    using System.IO;

    public static class Task
    {
        public static string Execute(string FilePath, string FileContents)
        {
            try
            {
                File.WriteAllBytes(FilePath, Convert.FromBase64String(FileContents));
                return FilePath;
            }
            catch (Exception e) { return e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        }
    }
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: FilePath
    Value: ''
    DefaultValue: ''
    Description: Remote file path to write to.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: FileContents
    Value: ''
    DefaultValue: ''
    Description: Base64 contents of the file to be written.
    SuggestedValues: []
    Optional: false
    DisplayInCommand: false
    FileOption: true
  ReferenceSourceLibraries: []
  ReferenceAssemblies: []
  EmbeddedResources: []